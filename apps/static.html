<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>BIMsurfer Static Mode</title>
<link rel="icon" type="image/png" href="../img/application_home.png" />
<link href="../css/dev.css" type="text/css" rel="stylesheet" />
<link href="../css/viewer.css" type="text/css" rel="stylesheet" />
<style>
canvas {
    width: 100%;
    height: 100%;
    display: block;
}
</style>
</head>

<body>
	<div id="viewer">
		<div id="overlay">
			<div id="inside">
				<a id="backButton">Back</a>
				<div id="stats"></div>
			</div>
		</div>
		<div id="settings">
		</div>
		<div id="canvasWrapper" style="width:100%;height:100%">
		</div>
		<div id="progressbar">
			<div id="progress"></div>
		</div>
	</div>
</body>

<script src="../gl-matrix.js"></script>
<script>
const inf = +Infinity;
window.xeogl = {};
xeogl.Model = class {
    constructor(args) {
        let self = this;
        this.scene = {
            canvas: {
                spinner: {
                    processes: 0
                }
            },
            _loading: 0,
            get loading() {
                return this._loading;
            },
            set loading(v) {
                this._loading = v;
                if (v === 0) {
                    self.fire("reallyLoaded");
                }
            }
        };
        this.geometriesCreated = new Set();
        this.init(args);       
    }

    init(args) {
        xeogl._apply(args, this);
    }

    clear() {}

    _addComponent() {}

    addChild(mesh) {
        var matrix = mesh.matrix ? new Float32Array(mesh.matrix) : mat4.identity(mat4.create());
        
        if (!this.geometriesCreated.has(mesh.geometry.id)) {
            const geom = mesh.geometry;
            const color = mesh.colorize;
            const colors = new Float32Array(geom.positions.length / 3 * color.length);
            let k = 0;
            for (let i = 0; i < geom.positions.length / 3; i++) {
                for (let j = 0; j < color.length; ++j) {
                    colors[k++] = color[j];
                }
            }
            this.layer.createGeometry(this.loaderId || 0, 0, 0, geom.id, geom.positions, geom.normals, colors, null, geom.indices, false, false);
            this.geometriesCreated.add(geom.id)
        }
        
        // @todo why is this part of the createObject() function signature
        var normalMatrix = mat3.create();
		mat3.fromMat4(normalMatrix, matrix);
		mat3.invert(normalMatrix, normalMatrix);
		mat3.transpose(normalMatrix, normalMatrix);
        
        var scaleMatrix = mat4.identity(mat4.create());

        const bounds = new Float32Array([inf, inf, inf, -inf, -inf, -inf]);
        const ps = mesh.geometry.positions;

        for (let i = 0; i < ps.length; i += 3) {
            for (let j = 0; j < 3; ++j) {
                if (ps[i+j] < bounds[j]) {
                    bounds[j] = ps[i+j];
                }
                if (ps[i+j] > bounds[j+3]) {
                    bounds[j+3] = ps[i+j];
                } 
            }
        }

        vec3.transformMat4(bounds.subarray(0), bounds.subarray(0), matrix);
        vec3.transformMat4(bounds.subarray(3), bounds.subarray(3), matrix);
        
        this.layer.createObject(this.loaderId || 0, 0, mesh.id, mesh.id, [mesh.geometry.id], matrix, normalMatrix, scaleMatrix, mesh.colorize[3] != 1., "IfcOpenShell", bounds);
    }
};
xeogl._isString =  function (value) {
    return (typeof value === 'string' || value instanceof String);
}
xeogl._apply = function (o, o2) {
    for (var name in o) {
        if (o.hasOwnProperty(name)) {
            o2[name] = o[name];
        }
    }
    return o2;
};
xeogl.scheduleTask = function(fn) {fn();};
xeogl.Geometry = class {
    constructor(scene, args) {
        xeogl._apply(args, this);
        this._id = xeogl.Geometry.counter;
    }

    get id() {
        return this._id;
    }

    static get counter() {
        xeogl.Geometry._counter = (xeogl.Geometry._counter || 0) + 1;
        return xeogl.Geometry._counter;
    }
}
xeogl.math = {
    mulMat4: function (a, b, dest) {
        if (!dest) {
            dest = a;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        var b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
        var b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
        var b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
        var b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

        return dest;
    },
    mat4: mat4.create
}
xeogl.LambertMaterial = class {
    constructor(scene, args) {
        xeogl._apply(args, this);
    }
};
xeogl.Mesh = class {
    constructor(scene, args) {
        xeogl._apply(args, this);
        this._id = xeogl.Mesh.counter;
    }

    get id() {
        return this._id;
    }

    static get counter() {
        xeogl.Mesh._counter = (xeogl.Mesh._counter || 0) + 1;
        return xeogl.Geometry._counter;
    }
};
</script>
<script src="../lib/xeogl/glTFModel.js"></script>
<script type="module" src="static.js"></script>
</html>